package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.DependencyModel;
import org.pragmatica.jbct.slice.model.KeyExtractorInfo;
import org.pragmatica.jbct.slice.model.MethodModel;
import org.pragmatica.jbct.slice.model.ResourceQualifierModel;
import org.pragmatica.jbct.slice.model.SliceModel;
import org.pragmatica.lang.Option;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.Unit;
import org.pragmatica.lang.utils.Causes;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;

/// Generates factory class for slice instantiation.
///
/// Generated factory contains:
///
///   - `create(Aspect, SliceCreationContext)` - returns typed slice instance
///   - `createSlice(Aspect, SliceCreationContext)` - returns Slice for Aether runtime
///
///
/// Slice dependencies get local proxy records that delegate to ctx.invoker().
/// Resource dependencies (annotated with @ResourceQualifier) use ctx.resources().provide().
/// Method interceptors (annotations with @ResourceQualifier on methods) use ctx.resources().provide()
/// and compose via interceptor.intercept(impl::method).
public class FactoryClassGenerator {
    private final Filer filer;
    private final Elements elements;
    private final Types types;
    private final DependencyVersionResolver versionResolver;

    public FactoryClassGenerator(Filer filer,
                                 Elements elements,
                                 Types types,
                                 DependencyVersionResolver versionResolver) {
        this.filer = filer;
        this.elements = elements;
        this.types = types;
        this.versionResolver = versionResolver;
    }

    public Result<Unit> generate(SliceModel model) {
        try {
            var factoryName = model.simpleName() + "Factory";
            var qualifiedName = model.packageName() + "." + factoryName;
            JavaFileObject file = filer.createSourceFile(qualifiedName);
            try (var writer = new PrintWriter(file.openWriter())) {
                generateFactoryClass(writer, model, factoryName);
            }
            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate factory class: " + e.getClass()
                                                                        .getSimpleName() + ": " + e.getMessage())
                         .result();
        }
    }

    private void generateFactoryClass(PrintWriter out, SliceModel model, String factoryName) {
        var sliceName = model.simpleName();
        var basePackage = model.packageName();
        // Resolve all dependencies
        var allDeps = model.dependencies()
                           .stream()
                           .map(versionResolver::resolve)
                           .toList();
        // Cache proxy methods per dependency to avoid repeated lookups
        var proxyMethodsCache = new LinkedHashMap<String, List<ProxyMethodInfo>>();
        for (var dep : allDeps) {
            if (!dep.isResource() && !dep.isPlainInterface()) {
                proxyMethodsCache.put(dep.interfaceQualifiedName(), collectProxyMethods(dep));
            }
        }
        // Package
        out.println("package " + basePackage + ";");
        out.println();
        // Imports
        generateImports(out, model, allDeps);
        out.println();
        // Class
        out.println("/**");
        out.println(" * Factory for " + sliceName + " slice.");
        out.println(" * Generated by slice-processor - do not edit manually.");
        out.println(" */");
        out.println("public final class " + factoryName + " {");
        out.println("    private " + factoryName + "() {}");
        out.println();
        // create() method
        generateCreateMethod(out, model, allDeps, proxyMethodsCache);
        out.println();
        // createSlice() method
        generateCreateSliceMethod(out, model);
        out.println("}");
    }

    private void generateImports(PrintWriter out,
                                 SliceModel model,
                                 List<DependencyModel> allDeps) {
        out.println("import org.pragmatica.aether.slice.Aspect;");
        out.println("import org.pragmatica.aether.slice.MethodHandle;");
        out.println("import org.pragmatica.aether.slice.MethodName;");
        out.println("import org.pragmatica.aether.slice.Slice;");
        out.println("import org.pragmatica.aether.slice.SliceCreationContext;");
        out.println("import org.pragmatica.aether.slice.SliceMethod;");
        out.println("import org.pragmatica.lang.Promise;");
        out.println("import org.pragmatica.lang.Unit;");
        out.println("import org.pragmatica.lang.type.TypeToken;");
        // Method interceptor imports
        if (model.hasMethodInterceptors()) {
            out.println("import org.pragmatica.aether.slice.MethodInterceptor;");
            out.println("import org.pragmatica.aether.slice.ProvisioningContext;");
            out.println("import org.pragmatica.lang.Functions.Fn1;");
        }
        out.println();
        out.println("import java.util.List;");
        // Import all dependency interfaces (deduplicated, using top-level class for nested types)
        var basePackage = model.packageName();
        var importedNames = new LinkedHashSet<String>();
        for (var dep : allDeps) {
            if (!dep.interfacePackage()
                    .equals(basePackage)) {
                importedNames.add(dep.importName());
            }
        }
        for (var importName : importedNames) {
            out.println("import " + importName + ";");
        }
    }

    private void generateCreateMethod(PrintWriter out,
                                       SliceModel model,
                                       List<DependencyModel> allDeps,
                                       Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var sliceName = model.simpleName();
        var methodName = lowercaseFirst(sliceName);
        // Split dependencies: resource deps, slice deps (get proxy records), plain interface deps
        var resourceDeps = allDeps.stream()
                                  .filter(DependencyModel::isResource)
                                  .toList();
        var sliceDeps = allDeps.stream()
                               .filter(d -> !d.isResource() && !d.isPlainInterface())
                               .toList();
        var plainDeps = allDeps.stream()
                               .filter(DependencyModel::isPlainInterface)
                               .toList();
        out.println("    public static Promise<" + sliceName + "> " + methodName + "(Aspect<" + sliceName + "> aspect,");
        out.println("                                              SliceCreationContext ctx) {");
        // Generate local proxy records ONLY for slice dependencies
        for (var dep : sliceDeps) {
            generateLocalProxyRecord(out, dep, proxyMethodsCache);
            out.println();
        }
        // Generate wrapper record if method interceptors are present
        if (model.hasMethodInterceptors()) {
            generateWrapperRecord(out, model);
            out.println();
        }
        // Build the creation chain
        generateCreationChain(out, model, resourceDeps, sliceDeps, plainDeps, proxyMethodsCache);
        out.println("    }");
    }

    private void generateWrapperRecord(PrintWriter out, SliceModel model) {
        var sliceName = model.simpleName();
        var wrapperName = sliceName + "Wrapper";
        // Generate record components - one Fn1 per method
        var components = new ArrayList<String>();
        for (var method : model.methods()) {
            var responseType = method.responseType()
                                     .toString();
            var paramType = method.parameterType()
                                  .toString();
            components.add("Fn1<Promise<" + responseType + ">, " + paramType + "> " + method.name() + "Fn");
        }
        out.println("        record " + wrapperName + "(" + String.join(",\n                                  ",
                                                                        components) + ")");
        out.println("               implements " + sliceName + " {");
        // Generate method implementations
        for (var method : model.methods()) {
            var responseType = method.responseType()
                                     .toString();
            var paramType = method.parameterType()
                                  .toString();
            out.println();
            out.println("            @Override");
            out.println("            public Promise<" + responseType + "> " + method.name() + "(" + paramType
                        + " request) {");
            out.println("                return " + method.name() + "Fn.apply(request);");
            out.println("            }");
        }
        out.println("        }");
    }

    private record AllEntry(String varName, String promiseExpression) {}

    /// Collect unique interceptor provisions across all methods, deduplicating by (type, config).
    private List<InterceptorEntry> collectUniqueInterceptors(SliceModel model) {
        var seen = new LinkedHashMap<String, InterceptorEntry>();
        for (var method : model.methods()) {
            for (var interceptor : method.interceptors()) {
                var key = interceptor.deduplicationKey();
                if (!seen.containsKey(key)) {
                    var varName = lowercaseFirst(interceptor.variableSafeName())
                                  + "_" + interceptor.configSection()
                                                     .replace('.', '_');
                    seen.put(key, new InterceptorEntry(varName, interceptor, method));
                }
            }
        }
        return new ArrayList<>(seen.values());
    }

    private record InterceptorEntry(String varName, ResourceQualifierModel qualifier, MethodModel firstMethod) {}

    private void generateCreationChain(PrintWriter out,
                                        SliceModel model,
                                        List<DependencyModel> resourceDeps,
                                        List<DependencyModel> sliceDeps,
                                        List<DependencyModel> plainDeps,
                                        Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var sliceName = model.simpleName();
        var entries = new ArrayList<AllEntry>();
        // Resource deps
        for (var resource : resourceDeps) {
            entries.add(new AllEntry(resource.parameterName(), generateResourceProvideCall(resource)));
        }
        // Interceptor deps (deduplicated)
        var interceptorEntries = collectUniqueInterceptors(model);
        for (var ie : interceptorEntries) {
            entries.add(new AllEntry(ie.varName(), generateInterceptorProvideCall(ie, model)));
        }
        // Slice method handles
        for (var dep : sliceDeps) {
            var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
            for (var method : methods) {
                var handle = new HandleInfo(dep, method);
                entries.add(new AllEntry(handle.varName(), generateMethodHandleCall(handle)));
            }
        }
        // Plain interface leaf deps (resources their factory methods need)
        // For now, plain interfaces are constructed synchronously inside .map()
        // Their resource deps should already be in the resource deps list

        if (entries.isEmpty()) {
            // No async deps â€” plain deps are constructed synchronously
            generateSyncOnlyBody(out, model, sliceName, plainDeps);
            return;
        }
        if (entries.size() > 15) {
            throw new IllegalStateException("Too many dependencies (" + entries.size()
                                            + ") for Promise.all() - maximum is 15");
        }
        // Generate Promise.all(...)
        out.println("        return Promise.all(");
        for (int i = 0; i < entries.size(); i++) {
            var entry = entries.get(i);
            var comma = (i < entries.size() - 1)
                        ? ","
                        : "";
            out.println("            " + entry.promiseExpression() + comma);
        }
        out.println("        )");
        // Generate .map((v1, v2, ...) -> { ... })
        var varNames = entries.stream()
                              .map(AllEntry::varName)
                              .toList();
        out.println("        .map((" + String.join(", ", varNames) + ") -> {");
        // Instantiate proxy records from handle vars
        for (var dep : sliceDeps) {
            var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
            var handleArgs = methods.stream()
                                    .map(m -> dep.parameterName() + "_" + m.name)
                                    .toList();
            out.println("            var " + dep.parameterName() + " = new " + dep.localRecordName() + "(" + String.join(", ",
                                                                                                                         handleArgs)
                        + ");");
        }
        // Construct plain interface deps
        for (var dep : plainDeps) {
            var factoryMethodName = lowercaseFirst(dep.interfaceSimpleName());
            out.println("            var " + dep.parameterName() + " = " + dep.sourceUsableName() + "."
                        + factoryMethodName + "();");
        }
        // Call factory and wrap
        var factoryArgs = model.dependencies()
                               .stream()
                               .map(DependencyModel::parameterName)
                               .toList();
        if (model.hasMethodInterceptors()) {
            out.println("            var impl = " + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                    factoryArgs)
                        + ");");
            out.println();
            generateInterceptorWrapping(out, model, interceptorEntries, "            ");
        } else {
            out.println("            return aspect.apply(" + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                             factoryArgs)
                        + "));");
        }
        out.println("        });");
    }

    private void generateNoDepInterceptorBody(PrintWriter out, SliceModel model, String sliceName) {
        var wrapperName = sliceName + "Wrapper";
        var factoryArgs = model.dependencies()
                               .stream()
                               .map(DependencyModel::parameterName)
                               .toList();
        out.println("        var impl = " + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                            factoryArgs)
                    + ");");
        out.println();
        // Generate wrapped functions
        for (var method : model.methods()) {
            var wrappedVar = method.name() + "Wrapped";
            out.println("        Fn1<Promise<" + method.responseType() + ">, " + method.parameterType() + "> " + wrappedVar
                        + " = impl::" + method.name() + ";");
        }
        out.println();
        var wrappedArgs = model.methods()
                               .stream()
                               .map(m -> m.name() + "Wrapped")
                               .toList();
        out.println("        return Promise.success(aspect.apply(new " + wrapperName + "(" + String.join(", ",
                                                                                                         wrappedArgs)
                    + ")));");
    }

    /// Generates body when there are no async entries (only plain/no deps).
    private void generateSyncOnlyBody(PrintWriter out,
                                       SliceModel model,
                                       String sliceName,
                                       List<DependencyModel> plainDeps) {
        if (model.hasMethodInterceptors()) {
            generateNoDepInterceptorBody(out, model, sliceName);
            return;
        }
        // Construct plain interface deps synchronously
        for (var dep : plainDeps) {
            var factoryMethodName = lowercaseFirst(dep.interfaceSimpleName());
            out.println("        var " + dep.parameterName() + " = " + dep.sourceUsableName() + "."
                        + factoryMethodName + "();");
        }
        var factoryArgs = buildFactoryArgs(model, plainDeps);
        out.println("        var instance = " + sliceName + "." + model.factoryMethodName() + "("
                    + String.join(", ", factoryArgs) + ");");
        out.println("        return Promise.success(aspect.apply(instance));");
    }

    /// Generate interceptor wrapping for each method.
    /// Interceptors compose inside-out: last annotation = innermost, first = outermost.
    private void generateInterceptorWrapping(PrintWriter out,
                                              SliceModel model,
                                              List<InterceptorEntry> allInterceptors,
                                              String indent) {
        var wrapperName = model.simpleName() + "Wrapper";
        // Build dedup key -> varName map
        var interceptorVarMap = new LinkedHashMap<String, String>();
        for (var ie : allInterceptors) {
            interceptorVarMap.put(ie.qualifier().deduplicationKey(), ie.varName());
        }
        for (var method : model.methods()) {
            var wrappedVar = method.name() + "Wrapped";
            if (method.hasInterceptors()) {
                // Build interceptor chain inside-out
                // Start with impl::method, then wrap from innermost (last) to outermost (first)
                var interceptors = method.interceptors();
                // innermost first (reverse order)
                var expression = "impl::" + method.name();
                for (int i = interceptors.size() - 1; i >= 0; i--) {
                    var ic = interceptors.get(i);
                    var icVarName = interceptorVarMap.get(ic.deduplicationKey());
                    expression = icVarName + ".intercept(" + expression + ")";
                }
                out.println(indent + "var " + wrappedVar + " = " + expression + ";");
            } else {
                out.println(indent + "Fn1<Promise<" + method.responseType() + ">, " + method.parameterType() + "> " + wrappedVar
                            + " = impl::" + method.name() + ";");
            }
        }
        out.println();
        var wrappedArgs = model.methods()
                               .stream()
                               .map(m -> m.name() + "Wrapped")
                               .toList();
        out.println(indent + "return aspect.apply(new " + wrapperName + "(" + String.join(", ", wrappedArgs) + "));");
    }

    /// Generate interceptor provisioning call with optional ProvisioningContext.
    private String generateInterceptorProvideCall(InterceptorEntry entry, SliceModel model) {
        var qualifier = entry.qualifier();
        var configSection = escapeJavaString(qualifier.configSection());
        return findKeyInfoForInterceptor(entry, model)
        .fold(() -> "ctx.resources().provide(MethodInterceptor.class, \"" + configSection + "\")",
              ki -> generateProvideWithContext(configSection, ki, entry.firstMethod()));
    }

    private String generateProvideWithContext(String configSection,
                                               KeyExtractorInfo ki,
                                               MethodModel method) {
        var paramType = method.parameterType()
                              .toString();
        var responseType = method.responseType()
                                  .toString();
        return "ctx.resources().provide(MethodInterceptor.class, \"" + configSection + "\",\n"
               + "                ProvisioningContext.provisioningContext()\n"
               + "                    .withTypeToken(new TypeToken<" + ki.keyType() + ">() {})\n"
               + "                    .withTypeToken(new TypeToken<" + responseType + ">() {})\n"
               + "                    .withKeyExtractor((Fn1<" + ki.keyType() + ", " + paramType + ">) "
               + ki.extractorExpression() + "))";
    }

    private Option<KeyExtractorInfo> findKeyInfoForInterceptor(InterceptorEntry entry, SliceModel model) {
        for (var method : model.methods()) {
            for (var interceptor : method.interceptors()) {
                if (interceptor.deduplicationKey()
                               .equals(entry.qualifier()
                                            .deduplicationKey())) {
                    if (method.keyExtractor()
                              .isPresent()) {
                        return method.keyExtractor();
                    }
                }
            }
        }
        return Option.none();
    }

    private List<String> buildFactoryArgs(SliceModel model, List<DependencyModel> plainDeps) {
        return model.dependencies()
                    .stream()
                    .map(DependencyModel::parameterName)
                    .toList();
    }

    private record HandleInfo(DependencyModel dep, ProxyMethodInfo method) {
        String varName() {
            return dep.parameterName() + "_" + method.name;
        }
    }

    private String generateMethodHandleCall(HandleInfo handle) {
        var artifact = escapeJavaString(handle.dep.fullArtifact()
                                              .or(() -> "UNRESOLVED"));
        var methodName = escapeJavaString(handle.method.name);
        return "ctx.invoker().methodHandle(\"" + artifact + "\", \"" + methodName + "\",\n"
               + "                                                     new TypeToken<" + handle.method.paramType
               + ">() {},\n" + "                                                     new TypeToken<" + handle.method.responseType
               + ">() {}).async()";
    }

    private record ProxyMethodInfo(String name, String responseType, String paramType) {}

    private List<ProxyMethodInfo> collectProxyMethods(DependencyModel dep) {
        var methods = new ArrayList<ProxyMethodInfo>();
        var interfaceElement = elements.getTypeElement(dep.interfaceQualifiedName());
        if (interfaceElement != null) {
            for (var enclosed : interfaceElement.getEnclosedElements()) {
                if (enclosed.getKind() == ElementKind.METHOD) {
                    var method = (ExecutableElement) enclosed;
                    if (!method.getModifiers()
                               .contains(Modifier.STATIC) &&
                    !method.getModifiers()
                           .contains(Modifier.DEFAULT) &&
                    method.getParameters()
                          .size() == 1) {
                        extractPromiseTypeArg(method.getReturnType())
                        .map(responseType -> toProxyMethodInfo(method, responseType))
                        .onPresent(methods::add);
                    }
                }
            }
        }
        return methods;
    }

    private ProxyMethodInfo toProxyMethodInfo(ExecutableElement method, String responseType) {
        var paramType = method.getParameters()
                              .getFirst()
                              .asType()
                              .toString();
        return new ProxyMethodInfo(method.getSimpleName()
                                         .toString(),
                                   responseType,
                                   paramType);
    }

    private void generateLocalProxyRecord(PrintWriter out,
                                          DependencyModel dep,
                                          Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var recordName = dep.localRecordName();
        var interfaceName = dep.interfaceLocalName();
        var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
        // Generate record with MethodHandle components
        var components = methods.stream()
                                .map(m -> "MethodHandle<" + m.responseType + ", " + m.paramType + "> " + m.name
                                          + "Handle")
                                .toList();
        out.println("        record " + recordName + "(" + String.join(", ", components) + ") implements " + interfaceName
                    + " {");
        // Generate method implementations
        for (var method : methods) {
            generateProxyMethod(out, method);
        }
        out.println("        }");
    }

    private void generateProxyMethod(PrintWriter out, ProxyMethodInfo method) {
        out.println();
        out.println("            @Override");
        out.println("            public Promise<" + method.responseType + "> " + method.name + "(" + method.paramType
                    + " request) {");
        out.println("                return " + method.name + "Handle.invoke(request);");
        out.println("            }");
    }

    private void generateCreateSliceMethod(PrintWriter out, SliceModel model) {
        var sliceName = model.simpleName();
        var methodName = lowercaseFirst(sliceName);
        var sliceRecordName = methodName + "Slice";
        out.println("    public static Promise<Slice> " + methodName + "Slice(Aspect<" + sliceName + "> aspect,");
        out.println("                                              SliceCreationContext ctx) {");
        // Generate local adapter record
        out.println("        record " + sliceRecordName + "(" + sliceName + " delegate) implements Slice, " + sliceName
                    + " {");
        out.println("            @Override");
        out.println("            public List<SliceMethod<?, ?>> methods() {");
        out.println("                return List.of(");
        // Generate SliceMethod entries for each method
        var methods = model.methods();
        for (int i = 0; i < methods.size(); i++) {
            var method = methods.get(i);
            var comma = (i < methods.size() - 1)
                        ? ","
                        : "";
            var escapedMethodName = escapeJavaString(method.name());
            out.println("                    new SliceMethod<>(");
            out.println("                        MethodName.methodName(\"" + escapedMethodName + "\").unwrap(),");
            out.println("                        delegate::" + method.name() + ",");
            out.println("                        new TypeToken<" + method.responseType() + ">() {},");
            out.println("                        new TypeToken<" + method.parameterType() + ">() {}");
            out.println("                    )" + comma);
        }
        out.println("                );");
        out.println("            }");
        // Generate delegate methods for the slice interface
        for (var method : methods) {
            out.println();
            out.println("            @Override");
            out.println("            public " + method.returnType() + " " + method.name() + "(" + method.parameterType()
                        + " " + method.parameterName() + ") {");
            out.println("                return delegate." + method.name() + "(" + method.parameterName() + ");");
            out.println("            }");
        }
        out.println("        }");
        out.println();
        out.println("        return " + methodName + "(aspect, ctx)");
        out.println("                   .map(" + sliceRecordName + "::new);");
        out.println("    }");
    }

    private Option<String> extractPromiseTypeArg(TypeMirror type) {
        if (type instanceof DeclaredType dt) {
            var typeArgs = dt.getTypeArguments();
            if (!typeArgs.isEmpty()) {
                return Option.some(typeArgs.getFirst()
                                           .toString());
            }
        }
        return Option.none();
    }

    /// Escapes a string for safe embedding in Java string literals.
    private String escapeJavaString(String input) {
        if (input == null) {
            return "";
        }
        var sb = new StringBuilder(input.length());
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            switch (c) {
                case '"' -> sb.append("\\\"");
                case '\\' -> sb.append("\\\\");
                case '\n' -> sb.append("\\n");
                case '\r' -> sb.append("\\r");
                case '\t' -> sb.append("\\t");
                default -> sb.append(c);
            }
        }
        return sb.toString();
    }

    /// Converts first letter to lowercase following JBCT naming conventions.
    private String lowercaseFirst(String name) {
        if (name == null || name.isEmpty()) {
            return "";
        }
        int i = 0;
        while (i < name.length() && Character.isUpperCase(name.charAt(i))) {
            i++;
        }
        if (i == 0) {
            return name;
        }
        if (i == 1) {
            return Character.toLowerCase(name.charAt(0)) + name.substring(1);
        }
        if (i < name.length()) {
            return name.substring(0, i - 1)
                       .toLowerCase() + name.substring(i - 1);
        }
        return name.toLowerCase();
    }

    /// Generate resource provisioning call: ctx.resources().provide(Type.class, "config.section")
    private String generateResourceProvideCall(DependencyModel resource) {
        return resource.resourceQualifier()
                       .map(qualifier -> "ctx.resources().provide("
                                         + qualifier.resourceTypeSimpleName()
                                         + ".class, \"" + escapeJavaString(qualifier.configSection()) + "\")")
                       .or("ctx.resources().provide(Object.class, \"unknown\")");
    }
}
