package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.DependencyModel;
import org.pragmatica.jbct.slice.model.KeyExtractorInfo;
import org.pragmatica.jbct.slice.model.MethodModel;
import org.pragmatica.jbct.slice.model.SliceModel;
import org.pragmatica.lang.Option;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.Unit;
import org.pragmatica.lang.utils.Causes;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/// Generates factory class for slice instantiation.
///
/// Generated factory contains:
///
///   - `create(Aspect, SliceCreationContext)` - returns typed slice instance
///   - `createSlice(Aspect, SliceCreationContext)` - returns Slice for Aether runtime
///
///
/// Slice dependencies get local proxy records that delegate to ctx.invoker().
/// Resource dependencies (annotated with @ResourceQualifier) use ctx.resources().provide().
///
/// When methods have @Aspect annotations, generates wrapper record with
/// aspect-wrapped method implementations.
///
/// Currently supported aspects:
///
///   - `CACHE` - Fully implemented with key extraction
///   - `LOG` - Planned, not yet implemented
///   - `METRICS` - Planned, not yet implemented
///   - `RETRY` - Planned, not yet implemented
///   - `TIMEOUT` - Planned, not yet implemented
///
public class FactoryClassGenerator {
    private final Filer filer;
    private final Elements elements;
    private final Types types;
    private final DependencyVersionResolver versionResolver;

    public FactoryClassGenerator(Filer filer,
                                 Elements elements,
                                 Types types,
                                 DependencyVersionResolver versionResolver) {
        this.filer = filer;
        this.elements = elements;
        this.types = types;
        this.versionResolver = versionResolver;
    }

    public Result<Unit> generate(SliceModel model) {
        try{
            var factoryName = model.simpleName() + "Factory";
            var qualifiedName = model.packageName() + "." + factoryName;
            JavaFileObject file = filer.createSourceFile(qualifiedName);
            try (var writer = new PrintWriter(file.openWriter())) {
                generateFactoryClass(writer, model, factoryName);
            }
            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate factory class: " + e.getClass()
                                                                        .getSimpleName() + ": " + e.getMessage())
                         .result();
        }
    }

    private void generateFactoryClass(PrintWriter out, SliceModel model, String factoryName) {
        var sliceName = model.simpleName();
        var basePackage = model.packageName();
        // Resolve all dependencies - all go through invoker
        var allDeps = model.dependencies()
                           .stream()
                           .map(versionResolver::resolve)
                           .toList();
        // Cache proxy methods per dependency to avoid repeated lookups
        var proxyMethodsCache = new HashMap<String, List<ProxyMethodInfo>>();
        for (var dep : allDeps) {
            proxyMethodsCache.put(dep.interfaceQualifiedName(), collectProxyMethods(dep));
        }
        // Package
        out.println("package " + basePackage + ";");
        out.println();
        // Imports
        generateImports(out, model, allDeps);
        out.println();
        // Class
        out.println("/**");
        out.println(" * Factory for " + sliceName + " slice.");
        out.println(" * Generated by slice-processor - do not edit manually.");
        out.println(" */");
        out.println("public final class " + factoryName + " {");
        out.println("    private " + factoryName + "() {}");
        out.println();
        // create() method
        generateCreateMethod(out, model, allDeps, proxyMethodsCache);
        out.println();
        // createSlice() method
        generateCreateSliceMethod(out, model);
        out.println("}");
    }

    private void generateImports(PrintWriter out,
                                 SliceModel model,
                                 List<DependencyModel> allDeps) {
        out.println("import org.pragmatica.aether.slice.Aspect;");
        out.println("import org.pragmatica.aether.slice.MethodHandle;");
        out.println("import org.pragmatica.aether.slice.MethodName;");
        out.println("import org.pragmatica.aether.slice.Slice;");
        out.println("import org.pragmatica.aether.slice.SliceCreationContext;");
        out.println("import org.pragmatica.aether.slice.SliceMethod;");
        out.println("import org.pragmatica.lang.Promise;");
        out.println("import org.pragmatica.lang.Unit;");
        out.println("import org.pragmatica.lang.type.TypeToken;");
        // Aspect-related imports
        if (model.hasAspects()) {
            out.println("import org.pragmatica.aether.slice.SliceRuntime;");
            out.println("import org.pragmatica.aether.infra.aspect.Aspects;");
            out.println("import org.pragmatica.lang.Functions.Fn1;");
        }
        if (model.hasCache()) {
            out.println("import org.pragmatica.aether.infra.aspect.Cache;");
            out.println("import org.pragmatica.aether.infra.aspect.CacheConfig;");
        }
        out.println();
        out.println("import java.util.List;");
        // Import all dependency interfaces
        var basePackage = model.packageName();
        for (var dep : allDeps) {
            if (!dep.interfacePackage()
                    .equals(basePackage)) {
                out.println("import " + dep.interfaceQualifiedName() + ";");
            }
        }
    }

    private void generateCreateMethod(PrintWriter out,
                                      SliceModel model,
                                      List<DependencyModel> allDeps,
                                      Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var sliceName = model.simpleName();
        var methodName = lowercaseFirst(sliceName);
        // Split dependencies: resource deps (with @ResourceQualifier), infra deps, and slice deps
        var resourceDeps = allDeps.stream()
                                  .filter(DependencyModel::isResource)
                                  .toList();
        var infraDeps = allDeps.stream()
                               .filter(d -> !d.isResource() && d.isInfrastructure())
                               .toList();
        var sliceDeps = allDeps.stream()
                               .filter(d -> !d.isResource() && !d.isInfrastructure())
                               .toList();
        out.println("    public static Promise<" + sliceName + "> " + methodName + "(Aspect<" + sliceName + "> aspect,");
        out.println("                                              SliceCreationContext ctx) {");
        // Generate local proxy records ONLY for slice dependencies
        for (var dep : sliceDeps) {
            generateLocalProxyRecord(out, dep, proxyMethodsCache);
            out.println();
        }
        // Generate wrapper record if aspects are present
        if (model.hasAspects()) {
            generateWrapperRecord(out, model);
            out.println();
        }
        // Build the creation chain
        if (model.hasAspects()) {
            generateAspectAllChain(out, model, resourceDeps, infraDeps, sliceDeps, proxyMethodsCache);
        } else if (resourceDeps.isEmpty() && infraDeps.isEmpty() && sliceDeps.isEmpty()) {
            // No dependencies at all
            var factoryArgs = model.dependencies()
                                   .stream()
                                   .map(DependencyModel::parameterName)
                                   .toList();
            out.println("        var instance = " + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                    factoryArgs)
                        + ");");
            out.println("        return Promise.success(aspect.apply(instance));");
        } else {
            generateAllChain(out, model, resourceDeps, infraDeps, sliceDeps, proxyMethodsCache);
        }
        out.println("    }");
    }

    private void generateWrapperRecord(PrintWriter out, SliceModel model) {
        var sliceName = model.simpleName();
        var wrapperName = sliceName + "Wrapper";
        // Generate record components - one Fn1 per method
        var components = new ArrayList<String>();
        for (var method : model.methods()) {
            var responseType = method.responseType()
                                     .toString();
            var paramType = method.parameterType()
                                  .toString();
            components.add("Fn1<Promise<" + responseType + ">, " + paramType + "> " + method.name() + "Fn");
        }
        out.println("        record " + wrapperName + "(" + String.join(",\n                                  ",
                                                                        components) + ")");
        out.println("               implements " + sliceName + " {");
        // Generate method implementations
        for (var method : model.methods()) {
            var responseType = method.responseType()
                                     .toString();
            var paramType = method.parameterType()
                                  .toString();
            out.println();
            out.println("            @Override");
            out.println("            public Promise<" + responseType + "> " + method.name() + "(" + paramType
                        + " request) {");
            out.println("                return " + method.name() + "Fn.apply(request);");
            out.println("            }");
        }
        out.println("        }");
    }

    private record AllEntry(String varName, String promiseExpression) {}

    private List<AllEntry> collectAllEntries(List<DependencyModel> resourceDeps,
                                             List<DependencyModel> infraDeps,
                                             List<DependencyModel> sliceDeps,
                                             Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var entries = new ArrayList<AllEntry>();
        // Resource deps
        for (var resource : resourceDeps) {
            entries.add(new AllEntry(resource.parameterName(), generateResourceProvideCall(resource)));
        }
        // Infra deps
        for (var infra : infraDeps) {
            entries.add(new AllEntry(infra.parameterName(), generateInfraCall(infra)));
        }
        // Slice method handles
        for (var dep : sliceDeps) {
            var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
            for (var method : methods) {
                var handle = new HandleInfo(dep, method);
                entries.add(new AllEntry(handle.varName(), generateMethodHandleCall(handle)));
            }
        }
        return entries;
    }

    private void generateAllChain(PrintWriter out,
                                  SliceModel model,
                                  List<DependencyModel> resourceDeps,
                                  List<DependencyModel> infraDeps,
                                  List<DependencyModel> sliceDeps,
                                  Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var sliceName = model.simpleName();
        var entries = collectAllEntries(resourceDeps, infraDeps, sliceDeps, proxyMethodsCache);
        if (entries.size() > 15) {
            throw new IllegalStateException("Too many dependencies (" + entries.size()
                                            + ") for Promise.all() - maximum is 15");
        }
        // Generate Promise.all(...)
        out.println("        return Promise.all(");
        for (int i = 0; i < entries.size(); i++) {
            var entry = entries.get(i);
            var comma = (i < entries.size() - 1)
                        ? ","
                        : "";
            out.println("            " + entry.promiseExpression() + comma);
        }
        out.println("        )");
        // Generate .map((v1, v2, ...) -> { ... })
        var varNames = entries.stream()
                              .map(AllEntry::varName)
                              .toList();
        out.println("        .map((" + String.join(", ", varNames) + ") -> {");
        // Instantiate proxy records from handle vars
        for (var dep : sliceDeps) {
            var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
            var handleArgs = methods.stream()
                                    .map(m -> dep.parameterName() + "_" + m.name)
                                    .toList();
            out.println("            var " + dep.parameterName() + " = new " + dep.localRecordName() + "(" + String.join(", ",
                                                                                                                         handleArgs)
                        + ");");
        }
        // Call factory
        var factoryArgs = model.dependencies()
                               .stream()
                               .map(DependencyModel::parameterName)
                               .toList();
        out.println("            return aspect.apply(" + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                         factoryArgs)
                    + "));");
        out.println("        });");
    }

    private void generateAspectAllChain(PrintWriter out,
                                        SliceModel model,
                                        List<DependencyModel> resourceDeps,
                                        List<DependencyModel> infraDeps,
                                        List<DependencyModel> sliceDeps,
                                        Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var sliceName = model.simpleName();
        var wrapperName = sliceName + "Wrapper";
        // Collect cache methods
        var cacheMethods = model.methods()
                                .stream()
                                .filter(m -> m.aspects()
                                              .hasCache())
                                .toList();
        if (cacheMethods.isEmpty()) {
            // No caches - same as non-aspect all() but with wrapper body
            var entries = collectAllEntries(resourceDeps, infraDeps, sliceDeps, proxyMethodsCache);
            if (entries.isEmpty()) {
                // No deps at all, just wrap - return Promise.success directly
                var factoryArgs = model.dependencies()
                                       .stream()
                                       .map(DependencyModel::parameterName)
                                       .toList();
                out.println("        var impl = " + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                    factoryArgs)
                            + ");");
                out.println();
                // Generate wrapped functions
                for (var method : model.methods()) {
                    var wrappedVar = method.name() + "Wrapped";
                    out.println("        Fn1<Promise<" + method.responseType() + ">, " + method.parameterType() + "> " + wrappedVar
                                + " = impl::" + method.name() + ";");
                }
                out.println();
                var wrappedArgs = model.methods()
                                       .stream()
                                       .map(m -> m.name() + "Wrapped")
                                       .toList();
                out.println("        return Promise.success(aspect.apply(new " + wrapperName + "(" + String.join(", ",
                                                                                                                 wrappedArgs)
                            + ")));");
                return;
            }
            if (entries.size() > 15) {
                throw new IllegalStateException("Too many dependencies (" + entries.size()
                                                + ") for Promise.all() - maximum is 15");
            }
            out.println("        return Promise.all(");
            for (int i = 0; i < entries.size(); i++) {
                var entry = entries.get(i);
                var comma = (i < entries.size() - 1)
                            ? ","
                            : "";
                out.println("            " + entry.promiseExpression() + comma);
            }
            out.println("        )");
            var varNames = entries.stream()
                                  .map(AllEntry::varName)
                                  .toList();
            out.println("        .map((" + String.join(", ", varNames) + ") -> {");
            // Instantiate proxy records
            for (var dep : sliceDeps) {
                var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
                var handleArgs = methods.stream()
                                        .map(m -> dep.parameterName() + "_" + m.name)
                                        .toList();
                out.println("            var " + dep.parameterName() + " = new " + dep.localRecordName() + "(" + String.join(", ",
                                                                                                                             handleArgs)
                            + ");");
            }
            // Create impl and wrap
            var factoryArgs = model.dependencies()
                                   .stream()
                                   .map(DependencyModel::parameterName)
                                   .toList();
            out.println("            var impl = " + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                    factoryArgs)
                        + ");");
            out.println();
            generateAspectWrapperBody(out, model, sliceName, wrapperName, "            ", List.of());
            out.println("        });");
            return;
        }
        // Has caches - need factory from SliceRuntime
        var cacheVarNames = new ArrayList<String>();
        // Build cache entries (need factory variable)
        var cacheEntries = new ArrayList<AllEntry>();
        for (var method : cacheMethods) {
            var cacheVarName = method.name() + "Cache";
            cacheVarNames.add(cacheVarName);
            var keyExtractor = getKeyExtractorOrThrow(method);
            var keyType = keyExtractor.keyType();
            var responseType = method.responseType()
                                     .toString();
            var cacheName = escapeJavaString(lowercaseFirst(sliceName) + "." + method.name());
            var cacheExpr = "CacheConfig.cacheConfig(\"" + cacheName + "\",\n"
                            + "                                                     new TypeToken<" + keyType
                            + ">() {},\n" + "                                                     new TypeToken<" + responseType
                            + ">() {})\n" + "                                        .async()\n"
                            + "                                        .flatMap(cfg -> factory.create(Cache.class, cfg).async())";
            cacheEntries.add(new AllEntry(cacheVarName, cacheExpr));
        }
        // Build non-cache entries (resources, infras, slice handles)
        var nonCacheEntries = collectAllEntries(resourceDeps, infraDeps, sliceDeps, proxyMethodsCache);
        // Combine all entries for Promise.all()
        var allEntries = new ArrayList<AllEntry>();
        allEntries.addAll(cacheEntries);
        allEntries.addAll(nonCacheEntries);
        if (allEntries.size() > 15) {
            throw new IllegalStateException("Too many dependencies (" + allEntries.size()
                                            + ") for Promise.all() - maximum is 15");
        }
        // Generate: SliceRuntime.getAspectFactory().async().flatMap(factory -> Promise.all(...).map(...))
        out.println("        return SliceRuntime.getAspectFactory()");
        out.println("                           .async()");
        out.println("                           .flatMap(factory -> Promise.all(");
        for (int i = 0; i < allEntries.size(); i++) {
            var entry = allEntries.get(i);
            var comma = (i < allEntries.size() - 1)
                        ? ","
                        : "";
            out.println("                               " + entry.promiseExpression() + comma);
        }
        out.println("                           )");
        var varNames = allEntries.stream()
                                 .map(AllEntry::varName)
                                 .toList();
        out.println("                           .map((" + String.join(", ", varNames) + ") -> {");
        // Instantiate proxy records
        for (var dep : sliceDeps) {
            var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
            var handleArgs = methods.stream()
                                    .map(m -> dep.parameterName() + "_" + m.name)
                                    .toList();
            out.println("                               var " + dep.parameterName() + " = new " + dep.localRecordName()
                        + "(" + String.join(", ", handleArgs) + ");");
        }
        // Create impl
        var factoryArgs = model.dependencies()
                               .stream()
                               .map(DependencyModel::parameterName)
                               .toList();
        out.println("                               var impl = " + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                                   factoryArgs)
                    + ");");
        out.println();
        generateAspectWrapperBody(out, model, sliceName, wrapperName, "                               ", cacheVarNames);
        out.println("                           }));");
    }

    private void generateAspectWrapperBody(PrintWriter out,
                                           SliceModel model,
                                           String sliceName,
                                           String wrapperName,
                                           String indent,
                                           List<String> cacheVarNames) {
        // Create wrapped functions for each method
        int cacheIdx = 0;
        for (var method : model.methods()) {
            var wrappedVar = method.name() + "Wrapped";
            if (method.aspects()
                      .hasCache()) {
                var keyExtractor = getKeyExtractorOrThrow(method);
                var cacheVar = cacheVarNames.get(cacheIdx++);
                out.println(indent + "var " + wrappedVar + " = Aspects.withCaching(impl::" + method.name() + ", " + keyExtractor.extractorExpression()
                            + ", " + cacheVar + ");");
            } else {
                out.println(indent + "Fn1<Promise<" + method.responseType() + ">, " + method.parameterType() + "> " + wrappedVar
                            + " = impl::" + method.name() + ";");
            }
        }
        out.println();
        // Return wrapped instance
        var wrappedArgs = model.methods()
                               .stream()
                               .map(m -> m.name() + "Wrapped")
                               .toList();
        out.println(indent + "return aspect.apply(new " + wrapperName + "(" + String.join(", ", wrappedArgs) + "));");
    }

    /// Gets the key extractor from method aspects, throwing if missing.
    /// This should never happen if MethodModel.extractAspects() works correctly.
    private KeyExtractorInfo getKeyExtractorOrThrow(MethodModel method) {
        return method.aspects()
                     .keyExtractor()
                     .or(() -> {
                             // This is a logic error - CACHE aspect should always have key extractor
        throw new IllegalStateException("CACHE aspect on method '" + method.name()
                                        + "' is missing key extractor. This indicates a bug in MethodModel.extractAspects().");
                         });
    }

    private record HandleInfo(DependencyModel dep, ProxyMethodInfo method) {
        String varName() {
            return dep.parameterName() + "_" + method.name;
        }
    }

    private String generateMethodHandleCall(HandleInfo handle) {
        var artifact = escapeJavaString(handle.dep.fullArtifact()
                                              .or(() -> "UNRESOLVED"));
        var methodName = escapeJavaString(handle.method.name);
        return "ctx.invoker().methodHandle(\"" + artifact + "\", \"" + methodName + "\",\n"
               + "                                                     new TypeToken<" + handle.method.paramType
               + ">() {},\n" + "                                                     new TypeToken<" + handle.method.responseType
               + ">() {}).async()";
    }

    private record ProxyMethodInfo(String name, String responseType, String paramType) {}

    private List<ProxyMethodInfo> collectProxyMethods(DependencyModel dep) {
        var methods = new ArrayList<ProxyMethodInfo>();
        var interfaceElement = elements.getTypeElement(dep.interfaceQualifiedName());
        if (interfaceElement != null) {
            for (var enclosed : interfaceElement.getEnclosedElements()) {
                if (enclosed.getKind() == ElementKind.METHOD) {
                    var method = (ExecutableElement) enclosed;
                    if (!method.getModifiers()
                               .contains(Modifier.STATIC) &&
                    !method.getModifiers()
                           .contains(Modifier.DEFAULT) &&
                    method.getParameters()
                          .size() == 1) {
                        extractPromiseTypeArg(method.getReturnType())
                        .onPresent(responseType -> {
                                       var paramType = method.getParameters()
                                                             .getFirst()
                                                             .asType()
                                                             .toString();
                                       methods.add(new ProxyMethodInfo(method.getSimpleName()
                                                                             .toString(),
                                                                       responseType,
                                                                       paramType));
                                   });
                    }
                }
            }
        }
        return methods;
    }

    private void generateLocalProxyRecord(PrintWriter out,
                                          DependencyModel dep,
                                          Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var recordName = dep.localRecordName();
        var interfaceName = dep.interfaceSimpleName();
        var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
        // Generate record with MethodHandle components
        var components = methods.stream()
                                .map(m -> "MethodHandle<" + m.responseType + ", " + m.paramType + "> " + m.name
                                          + "Handle")
                                .toList();
        out.println("        record " + recordName + "(" + String.join(", ", components) + ") implements " + interfaceName
                    + " {");
        // Generate method implementations
        for (var method : methods) {
            generateProxyMethod(out, method);
        }
        out.println("        }");
    }

    private void generateProxyMethod(PrintWriter out, ProxyMethodInfo method) {
        out.println();
        out.println("            @Override");
        out.println("            public Promise<" + method.responseType + "> " + method.name + "(" + method.paramType
                    + " request) {");
        out.println("                return " + method.name + "Handle.invoke(request);");
        out.println("            }");
    }

    private void generateCreateSliceMethod(PrintWriter out, SliceModel model) {
        var sliceName = model.simpleName();
        var methodName = lowercaseFirst(sliceName);
        var sliceRecordName = methodName + "Slice";
        out.println("    public static Promise<Slice> " + methodName + "Slice(Aspect<" + sliceName + "> aspect,");
        out.println("                                              SliceCreationContext ctx) {");
        // Generate local adapter record
        out.println("        record " + sliceRecordName + "(" + sliceName + " delegate) implements Slice, " + sliceName
                    + " {");
        out.println("            @Override");
        out.println("            public List<SliceMethod<?, ?>> methods() {");
        out.println("                return List.of(");
        // Generate SliceMethod entries for each method
        var methods = model.methods();
        for (int i = 0; i < methods.size(); i++) {
            var method = methods.get(i);
            var comma = (i < methods.size() - 1)
                        ? ","
                        : "";
            var escapedMethodName = escapeJavaString(method.name());
            // Note: MethodName.unwrap() is safe here because method names are validated
            // at annotation processing time per RFC-0001
            out.println("                    new SliceMethod<>(");
            out.println("                        MethodName.methodName(\"" + escapedMethodName + "\").unwrap(),");
            out.println("                        delegate::" + method.name() + ",");
            out.println("                        new TypeToken<" + method.responseType() + ">() {},");
            out.println("                        new TypeToken<" + method.parameterType() + ">() {}");
            out.println("                    )" + comma);
        }
        out.println("                );");
        out.println("            }");
        // Generate delegate methods for the slice interface
        for (var method : methods) {
            out.println();
            out.println("            @Override");
            out.println("            public " + method.returnType() + " " + method.name() + "(" + method.parameterType()
                        + " " + method.parameterName() + ") {");
            out.println("                return delegate." + method.name() + "(" + method.parameterName() + ");");
            out.println("            }");
        }
        out.println("        }");
        out.println();
        out.println("        return " + methodName + "(aspect, ctx)");
        out.println("                   .map(" + sliceRecordName + "::new);");
        out.println("    }");
    }

    private Option<String> extractPromiseTypeArg(TypeMirror type) {
        if (type instanceof DeclaredType dt) {
            var typeArgs = dt.getTypeArguments();
            if (!typeArgs.isEmpty()) {
                return Option.some(typeArgs.getFirst()
                                           .toString());
            }
        }
        return Option.none();
    }

    /// Escapes a string for safe embedding in Java string literals.
    /// Handles quotes, backslashes, and common control characters.
    private String escapeJavaString(String input) {
        if (input == null) {
            return "";
        }
        var sb = new StringBuilder(input.length());
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            switch (c) {
                case '"' -> sb.append("\\\"");
                case '\\' -> sb.append("\\\\");
                case '\n' -> sb.append("\\n");
                case '\r' -> sb.append("\\r");
                case '\t' -> sb.append("\\t");
                default -> sb.append(c);
            }
        }
        return sb.toString();
    }

    /// Converts first letter to lowercase following JBCT naming conventions.
    /// Handles acronyms properly: "HTTPService" -> "httpService", "IOReader" -> "ioReader"
    private String lowercaseFirst(String name) {
        if (name == null || name.isEmpty()) {
            return "";
        }
        // Find the end of leading uppercase sequence
        int i = 0;
        while (i < name.length() && Character.isUpperCase(name.charAt(i))) {
            i++;
        }
        if (i == 0) {
            // Already lowercase
            return name;
        }
        if (i == 1) {
            // Single uppercase letter: "Service" -> "service"
            return Character.toLowerCase(name.charAt(0)) + name.substring(1);
        }
        // Acronym: "HTTPService" -> "httpService", "HTTP" -> "http"
        // Lowercase all but last uppercase if followed by lowercase
        if (i < name.length()) {
            // There's more after the acronym, keep last uppercase
            return name.substring(0, i - 1)
                       .toLowerCase() + name.substring(i - 1);
        }
        // Entire string is uppercase acronym: "HTTP" -> "http"
        return name.toLowerCase();
    }

    private String generateInfraCall(DependencyModel infra) {
        var interfaceName = infra.interfaceSimpleName();
        var factoryMethodName = toFactoryMethodName(interfaceName);
        return "Promise.success(" + interfaceName + "." + factoryMethodName + "())";
    }

    /// Generate resource provisioning call: ctx.resources().provide(Type.class, "config.section")
    private String generateResourceProvideCall(DependencyModel resource) {
        var qualifier = resource.resourceQualifier()
                                .or(() -> {
                                        throw new IllegalStateException("Resource dependency without @ResourceQualifier: " + resource.parameterName());
                                    });
        var resourceType = qualifier.resourceTypeSimpleName();
        var configSection = escapeJavaString(qualifier.configSection());
        return "ctx.resources().provide(" + resourceType + ".class, \"" + configSection + "\")";
    }

    private String toFactoryMethodName(String className) {
        return lowercaseFirst(className);
    }
}
