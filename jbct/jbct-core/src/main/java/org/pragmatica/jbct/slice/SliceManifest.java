package org.pragmatica.jbct.slice;

import org.pragmatica.lang.Option;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.utils.Causes;

import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.pragmatica.lang.Result.lift;

/// Model for per-slice manifest files generated by slice-processor.
/// Used by Maven plugin to package slices into separate artifacts.
public record SliceManifest(String sliceName,
                            String artifactSuffix,
                            String slicePackage,
                            List<String> implClasses,
                            List<String> requestClasses,
                            List<String> responseClasses,
                            String baseArtifact,
                            String implArtifactId,
                            List<SliceDependency> dependencies,
                            String configFile) {
    public SliceManifest {
        implClasses = List.copyOf(implClasses);
        requestClasses = List.copyOf(requestClasses);
        responseClasses = List.copyOf(responseClasses);
        dependencies = List.copyOf(dependencies);
    }

    /// Dependency information for blueprint generation.
    public record SliceDependency(String interfaceQualifiedName,
                                  String artifact,
                                  String version,
                                  boolean external) {
        public static SliceDependency sliceDependency(String interfaceQualifiedName,
                                                      String artifact,
                                                      String version,
                                                      boolean external) {
            return new SliceDependency(interfaceQualifiedName, artifact, version, external);
        }
    }

    /// Load a slice manifest from a .manifest file.
    public static Result<SliceManifest> load(Path manifestPath) {
        return lift(Causes::fromThrowable, () -> Files.newInputStream(manifestPath)).flatMap(SliceManifest::load);
    }

    /// Load a slice manifest from an input stream.
    public static Result<SliceManifest> load(InputStream input) {
        return lift(Causes::fromThrowable, () -> loadProperties(input)).flatMap(SliceManifest::fromProperties);
    }

    private static Properties loadProperties(InputStream input) throws java.io.IOException {
        var props = new Properties();
        props.load(input);
        return props;
    }

    private static Result<SliceManifest> fromProperties(Properties props) {
        return Option.option(props.getProperty("slice.name"))
                     .filter(s -> !s.isEmpty())
                     .toResult(Causes.cause("Missing required property: slice.name"))
                     .map(sliceName -> buildManifest(sliceName, props));
    }

    private static SliceManifest buildManifest(String sliceName, Properties props) {
        var artifactSuffix = getPropertyOrEmpty(props, "slice.artifactSuffix");
        var slicePackage = getPropertyOrEmpty(props, "slice.package");
        var implClasses = parseList(getPropertyOrEmpty(props, "impl.classes"));
        var requestClasses = parseList(getPropertyOrEmpty(props, "request.classes"));
        var responseClasses = parseList(getPropertyOrEmpty(props, "response.classes"));
        var baseArtifact = getPropertyOrEmpty(props, "base.artifact");
        var implArtifactId = getPropertyOrEmpty(props, "slice.artifactId");
        var dependencies = parseDependencies(props);
        var configFile = getPropertyOrEmpty(props, "config.file");
        return new SliceManifest(sliceName,
                                 artifactSuffix,
                                 slicePackage,
                                 implClasses,
                                 requestClasses,
                                 responseClasses,
                                 baseArtifact,
                                 implArtifactId,
                                 dependencies,
                                 configFile);
    }

    private static String getPropertyOrEmpty(Properties props, String key) {
        return Option.option(props.getProperty(key))
                     .or("");
    }

    private static final Logger LOG = LoggerFactory.getLogger(SliceManifest.class);

    private static List<SliceDependency> parseDependencies(Properties props) {
        return Option.option(props.getProperty("dependencies.count", "0"))
                     .flatMap(SliceManifest::parseCount)
                     .map(count -> buildDependencyList(props, count))
                     .onEmpty(() -> LOG.warn("Invalid dependencies.count in manifest, using 0"))
                     .or(List.of());
    }

    private static Option<Integer> parseCount(String countStr) {
        return Result.lift1(Causes::fromThrowable, Integer::parseInt, countStr)
                     .option();
    }

    private static List<SliceDependency> buildDependencyList(Properties props, int count) {
        return java.util.stream.IntStream.range(0, count)
                   .mapToObj(i -> parseDependency(props, i))
                   .flatMap(Option::stream)
                   .toList();
    }

    private static Option<SliceDependency> parseDependency(Properties props, int index) {
        var prefix = "dependency." + index + ".";
        var interfaceName = props.getProperty(prefix + "interface", "");
        return Option.option(interfaceName)
                     .filter(s -> !s.isEmpty())
                     .map(name -> SliceDependency.sliceDependency(name,
                                                                  props.getProperty(prefix + "artifact", ""),
                                                                  props.getProperty(prefix + "version", ""),
                                                                  Boolean.parseBoolean(props.getProperty(prefix
                                                                                                         + "external",
                                                                                                         "false"))));
    }

    private static List<String> parseList(String value) {
        return Option.option(value)
                     .filter(s -> !s.isEmpty())
                     .map(s -> Arrays.stream(s.split(","))
                                     .map(String::trim)
                                     .filter(part -> !part.isEmpty())
                                     .toList())
                     .or(List.of());
    }

    /// Get all classes that should go into the impl artifact.
    /// Includes implementation classes, request types, and response types.
    public List<String> allImplClasses() {
        return Stream.of(implClasses, requestClasses, responseClasses)
                     .flatMap(List::stream)
                     .toList();
    }

    /// Convert class name to class file path (relative).
    /// Handles nested classes: OuterClass.InnerClass -> OuterClass$InnerClass
    /// Uses heuristic: package parts are lowercase, class names start uppercase.
    /// Example: org.example.MyClass -> org/example/MyClass.class
    /// Example: org.example.MyClass.Inner -> org/example/MyClass$Inner.class
    public static String classToPath(String className) {
        return classNameToFilePath(className) + ".class";
    }

    /// Convert fully qualified class name to file path (without .class extension).
    /// Package dots become /, nested class dots become $.
    private static String classNameToFilePath(String className) {
        var parts = className.split("\\.");
        var sb = new StringBuilder();
        var inClassName = false;
        for (int i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (i > 0) {
                sb.append(inClassName
                          ? '$'
                          : '/');
            }
            sb.append(part);
            if (!inClassName && !part.isEmpty() && Character.isUpperCase(part.charAt(0))) {
                inClassName = true;
            }
        }
        return sb.toString();
    }

    /// Convert class name to all possible class file paths (including inner classes).
    /// Example: org.example.MyClass$Inner -> org/example/MyClass$Inner.class
    public static List<String> classToPathsWithInner(String className, Path classesDir) {
        var basePath = classNameToFilePath(className);
        var baseFile = classesDir.resolve(basePath + ".class");
        if (!Files.exists(baseFile)) {
            return List.of();
        }
        var baseClassPath = basePath + ".class";
        var innerClasses = findInnerClasses(baseFile, classesDir);
        return Stream.concat(Stream.of(baseClassPath),
                             innerClasses.stream())
                     .toList();
    }

    private static List<String> findInnerClasses(Path baseFile, Path classesDir) {
        return lift(Causes::fromThrowable,
                    () -> listInnerClassPaths(baseFile, classesDir)).onFailure(cause -> LOG.debug("Failed to list inner classes: {}",
                                                                                                  cause.message()))
                   .or(List.of());
    }

    private static List<String> listInnerClassPaths(Path baseFile, Path classesDir) throws java.io.IOException {
        var parent = baseFile.getParent();
        var simpleName = baseFile.getFileName()
                                 .toString()
                                 .replace(".class", "");
        try (var stream = Files.list(parent)) {
            return stream.filter(p -> p.getFileName()
                                       .toString()
                                       .startsWith(simpleName + "$"))
                         .filter(p -> p.getFileName()
                                       .toString()
                                       .endsWith(".class"))
                         .map(p -> classesDir.relativize(p)
                                             .toString()
                                             .replace('\\', '/'))
                         .toList();
        }
    }
}
