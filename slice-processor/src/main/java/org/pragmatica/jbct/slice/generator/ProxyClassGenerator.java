package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.DependencyModel;
import org.pragmatica.jbct.slice.model.SliceModel;
import org.pragmatica.lang.Option;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.Unit;
import org.pragmatica.lang.utils.Causes;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

public class ProxyClassGenerator {
    private final Filer filer;
    private final Elements elements;
    private final Types types;

    private static final ClassName SLICE_INVOKER_FACADE = ClassName.get("org.pragmatica.aether.slice",
                                                                        "SliceInvokerFacade");

    public ProxyClassGenerator(Filer filer, Elements elements, Types types) {
        this.filer = filer;
        this.elements = elements;
        this.types = types;
    }

    public Result<Unit> generate(DependencyModel dependency, SliceModel context) {
        try{
            var proxyName = dependency.proxyClassName();
            var interfaceType = TypeName.get(dependency.interfaceType());
            var classBuilder = TypeSpec.classBuilder(proxyName)
                                       .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                                       .addSuperinterface(interfaceType)
                                       .addJavadoc("Proxy implementation of $L.\n",
                                                   dependency.interfaceSimpleName())
                                       .addJavadoc("Delegates all calls to SliceInvoker.\n")
                                       .addJavadoc("Generated by slice-processor - do not edit manually.\n");
            // Fields
            classBuilder.addField(SLICE_INVOKER_FACADE, "invoker", Modifier.PRIVATE, Modifier.FINAL);
            classBuilder.addField(String.class, "artifact", Modifier.PRIVATE, Modifier.FINAL);
            // Constructor
            classBuilder.addMethod(MethodSpec.constructorBuilder()
                                             .addModifiers(Modifier.PUBLIC)
                                             .addParameter(SLICE_INVOKER_FACADE, "invoker")
                                             .addParameter(String.class, "artifact")
                                             .addStatement("this.invoker = invoker")
                                             .addStatement("this.artifact = artifact")
                                             .build());
            // Methods - load interface to get method details
            var interfaceElement = elements.getTypeElement(dependency.interfaceQualifiedName());
            if (interfaceElement != null) {
                for (var enclosed : interfaceElement.getEnclosedElements()) {
                    if (enclosed.getKind() == ElementKind.METHOD) {
                        var method = (ExecutableElement) enclosed;
                        if (!method.getModifiers()
                                   .contains(Modifier.STATIC) &&
                        !method.getModifiers()
                               .contains(Modifier.DEFAULT)) {
                            var proxyMethod = generateProxyMethod(method);
                            if (proxyMethod.isEmpty()) {
                                return Causes.cause("Failed to generate proxy method: " + method.getSimpleName())
                                             .result();
                            }
                            classBuilder.addMethod(proxyMethod.unwrap());
                        }
                    }
                }
            }
            // toString
            classBuilder.addMethod(MethodSpec.methodBuilder("toString")
                                             .addAnnotation(Override.class)
                                             .addModifiers(Modifier.PUBLIC)
                                             .returns(String.class)
                                             .addStatement("return $S + artifact + $S", proxyName + "[", "]")
                                             .build());
            var javaFile = JavaFile.builder(context.apiPackage(),
                                            classBuilder.build())
                                   .indent("    ")
                                   .build();
            javaFile.writeTo(filer);
            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate proxy class: " + e.getMessage())
                         .result();
        }
    }

    private Option<MethodSpec> generateProxyMethod(ExecutableElement method) {
        var methodName = method.getSimpleName()
                               .toString();
        var returnType = method.getReturnType();
        var params = method.getParameters();
        if (params.size() != 1) {
            return Option.none();
        }
        var param = params.getFirst();
        var paramType = param.asType();
        var paramName = param.getSimpleName()
                             .toString();
        // Extract response type from Promise<T>
        var responseType = extractPromiseTypeArg(returnType);
        if (responseType.isEmpty()) {
            return Option.none();
        }
        return Option.some(MethodSpec.methodBuilder(methodName)
                                     .addAnnotation(Override.class)
                                     .addModifiers(Modifier.PUBLIC)
                                     .returns(TypeName.get(returnType))
                                     .addParameter(TypeName.get(paramType),
                                                   paramName)
                                     .addStatement("return invoker.invokeAndWait(artifact, $S, $L, $T.class)",
                                                   methodName,
                                                   paramName,
                                                   responseType.unwrap())
                                     .build());
    }

    private Option<TypeMirror> extractPromiseTypeArg(TypeMirror type) {
        if (type instanceof DeclaredType dt) {
            var typeArgs = dt.getTypeArguments();
            if (!typeArgs.isEmpty()) {
                return Option.some(typeArgs.getFirst());
            }
        }
        return Option.none();
    }
}
